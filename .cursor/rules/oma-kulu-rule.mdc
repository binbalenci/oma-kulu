---
alwaysApply: true
---
# Oma Kulu - Cursor Development Rules

## General Guidelines

### Communication

- **Always start responses with "YO ALPHA!"** when beginning work on a task
- Be direct and action-oriented in explanations
- Show what you're doing, not just what you plan to do

### Code Quality

- **Always ensure linter passes after changing code**
- Run `read_lints` on modified files before completing a task
- Fix all linter errors and warnings immediately
- Use proper TypeScript types - no `any` types unless absolutely necessary

### Project Knowledge

- **Read these files first** before making architectural decisions:
  - `docs/APP_SPEC.md` - Complete app specification and user flows
  - `docs/ROADMAP.md` - Current development phase and feature status
- These documents are the single source of truth for requirements

---

## Components & Technical Patterns

### Global Snackbar (Toast Notifications)

- **Always use the global Snackbar** for user feedback, never create local toast/notification state
- Import: `import { useSnackbar } from "@/components/snackbar-provider";`
- Usage: `const { showSnackbar } = useSnackbar();`
- Call: `showSnackbar("Your message here");` or `showSnackbar("Message", 5000);` for custom duration

**When to use Snackbar:**

- Success confirmations: "Budget saved successfully!"
- Error messages: "No data found for previous month"
- Info notifications: "Copied 5 items from January 2025"
- Warnings: "Cannot delete: item is in use"

**Example:**

```typescript
const handleSave = () => {
  // ... save logic
  showSnackbar("Changes saved successfully!");
};
```

### Data Storage

- **Database:** Use Supabase (PostgreSQL) via `lib/database.ts` for all data operations
- **Compatibility Layer:** `lib/storage.ts` re-exports database functions for backward compatibility - import from either file
- All data operations are **async** - use async/await or Promise.all for multiple operations
- Load data on component mount and when month changes (if month-dependent)
- Save data immediately after state updates using async functions

**Pattern:**

```typescript
// Load data on mount/focus
React.useEffect(() => {
  (async () => {
    const [incomes, invoices, budgets] = await Promise.all([
      loadIncomes(monthKey),
      loadInvoices(monthKey),
      loadBudgets(monthKey),
    ]);
    setIncomes(incomes);
    setInvoices(invoices);
    setBudgets(budgets);
  })();
}, [monthKey]);

// Save data after updates
const handleSave = async () => {
  const success = await saveIncome(income);
  if (success) {
    showSnackbar("Income saved!");
  }
};
```

### Month Context

- Use `MonthProvider` and `useMonth()` hook for synchronized month state across tabs
- Import: `import { useMonth } from "@/lib/month-context";`
- All tabs (Home, Transactions, Reports) share the same month state
- Month changes in one tab automatically sync to others

**Pattern:**

```typescript
const { currentMonth, setCurrentMonth } = useMonth();
const monthKey = format(currentMonth, "yyyy-MM");
```

### Navigation

- Use `expo-router` for navigation
- Import: `import { useRouter } from "expo-router";`
- Navigate: `router.push("/(tabs)/categories");`
- **Tab structure:** Home (default), Transactions, Reports, Categories

### UI Components

- Use React Native Paper components consistently
- Import theme: `import { useTheme } from "react-native-paper";`
- Access colors: `theme.colors.primary`, `theme.colors.error`, etc.
- Use proper spacing: multiples of 4 (4, 8, 12, 16, 24, 32)

### State Management

- Use React hooks for local state
- Keep state as close to where it's used as possible
- Use `React.useCallback` for functions passed as props
- Use `React.useMemo` for expensive computations
- Use `useMonth()` hook for month state synchronization across tabs

### Logging & Monitoring

- **Always use the Logger utility** for all logging operations
- Import: `import logger from "@/app/utils/logger";`
- Logger integrates with Sentry for error tracking and monitoring

**Logger Methods:**

```typescript
// Error logging
logger.error(error, { operation: "save_income", data });

// Navigation tracking
logger.navigationAction("BudgetScreen", { month: currentMonth });

// User actions
logger.userAction("mark_paid", { itemId: "123", type: "income" });

// Data operations
logger.dataAction("load_budgets", { month: "2025-01" });

// Database operations
logger.databaseError(error, "saveIncome", { income });
logger.databaseSuccess("saveIncome", { incomeId: "123" });

// Performance warnings
logger.performanceWarning("loadTransactions", duration, 3000);

// Breadcrumbs for user journey
logger.breadcrumb("User marked income as paid", "user_action", { itemId });
```

**Best Practices:**

- Log navigation on every screen load
- Log user interactions for key actions
- Log database operations (success and errors)
- Use structured context objects for all logs
- Performance warnings automatically trigger for operations > 3 seconds

---

## App-Specific Patterns

### Budget View

- Month selector format: `format(date, "MMMM yyyy")`
- Month key format: `format(date, "yyyy-MM")`
- Always filter budgets by current month: `budgets.filter((b) => b.month === curMonth)`
- Calculate "Money to assign": `expectedIncome - expectedExpenses - totalAllocated`
  - Includes ALL invoices/incomes for the month (paid or unpaid) - represents remaining money to allocate
- Calculate "Actual in bank": `totalIncome - totalExpenses` 
  - Only includes paid transactions from current month with date <= today (excludes future-dated transactions)
  - Filters: `status === 'paid'` AND `date >= monthStart` AND `date <= monthEnd` AND `date <= today`

### Transactions

- Date format: `yyyy-MM-dd` (ISO format)
- Status: `"upcoming"` or `"paid"`
- Amount convention: positive for income, negative for expenses
- Always include `created_at` timestamp

### Templates (Recurring Items)

- Type: `"income"` or `"expense"`
- Store typical amounts as positive numbers
- Convert to negative when creating expense transactions
- Filter by `enabled !== false` when displaying

### Progress Bars & Color Coding

```typescript
const getProgressColor = (ratio: number) => {
  if (ratio === 0) return theme.colors.surfaceDisabled;
  if (ratio < 0.75) return "#4caf50"; // green
  if (ratio < 0.96) return "#ff9800"; // orange
  return "#f44336"; // red
};
```

---

## File Organization

```
app/
  â”œâ”€â”€ (tabs)/           # Tab screens (index=Home, transactions, reports, categories)
  â”‚   â”œâ”€â”€ _layout.tsx  # Tab layout configuration
  â”‚   â”œâ”€â”€ index.tsx     # Home/Budget screen
  â”‚   â”œâ”€â”€ transactions.tsx
  â”‚   â”œâ”€â”€ reports.tsx
  â”‚   â””â”€â”€ categories.tsx
  â”œâ”€â”€ _layout.tsx       # Root layout with providers
  â”œâ”€â”€ modal.tsx         # Modal screens
  â””â”€â”€ utils/
      â””â”€â”€ logger.ts     # Logger utility (Sentry integration)

components/
  â”œâ”€â”€ snackbar-provider.tsx  # Global snackbar context
  â”œâ”€â”€ passcode-gate.tsx      # Authentication with session management
  â””â”€â”€ ui/                    # Reusable UI components

lib/
  â”œâ”€â”€ database.ts       # Supabase database operations (PRIMARY)
  â”œâ”€â”€ storage.ts        # Compatibility layer (re-exports database functions)
  â”œâ”€â”€ types.ts          # TypeScript interfaces
  â”œâ”€â”€ supabase.ts       # Supabase client configuration
  â”œâ”€â”€ month-context.tsx # Month state provider for tab synchronization
  â”œâ”€â”€ session.ts        # Passcode session management (24-hour persistence)
  â””â”€â”€ passcode.ts       # Passcode hashing utilities

docs/
  â”œâ”€â”€ APP_SPEC.md       # Feature specifications
  â”œâ”€â”€ ROADMAP.md        # Development phases
  â””â”€â”€ *.md              # Additional documentation
```

---

## Common Tasks

### Documentation Maintenance

**Always keep documentation in sync with implementation:**

**Update `docs/APP_SPEC.md` when:**

- Adding, removing, or modifying features
- Changing app requirements or user flows
- Making architectural changes (e.g., storage â†’ database migration)
- Updating data models or business logic
- Review the conversation history to identify what changed
- Update relevant sections to reflect current implementation

**Update `docs/ROADMAP.md` only when:**

- User explicitly asks about roadmap items
- User wants to change app vision or direction
- Completing a significant milestone or phase
- Marking items as done/in-progress

### Adding a New Feature

1. Check `docs/ROADMAP.md` to confirm it's in the current phase
2. Review `docs/APP_SPEC.md` for requirements
3. Implement following existing patterns
4. Use global Snackbar for user feedback
5. Run linter and fix all errors
6. **Update `docs/APP_SPEC.md`** to reflect the new feature

### Adding a New Type

1. Add interface to `lib/types.ts`
2. Create database functions in `lib/database.ts`:
   - `load*` function: async function that queries Supabase
   - `save*` function: async function that upserts to Supabase
   - `delete*` function: async function that deletes from Supabase
3. Follow naming convention: `load*`, `save*`, `delete*` functions
4. Export functions from `lib/database.ts`
5. Re-export in `lib/storage.ts` for backward compatibility
6. Handle errors gracefully: return empty arrays/defaults on error
7. Log operations using `logger.databaseSuccess()` and `logger.databaseError()`

### Creating a New Screen

1. Add file to `app/(tabs)/` for tab screens
2. Register in `app/(tabs)/_layout.tsx` if it's a tab (set title, icon, etc.)
3. Use `useTheme()` for consistent styling
4. Import and use `useSnackbar()` for notifications
5. Use `useMonth()` hook if the screen needs month synchronization
6. Log navigation: `logger.navigationAction("ScreenName", { data })` in `useFocusEffect` or `useEffect`
7. Implement pull-to-refresh using `RefreshControl` for data reloading
8. Follow existing screen structure: state, effects (load data), render
9. Load data on mount and when month changes (if applicable)

**Example:**

```typescript
export default function MyScreen() {
  const { currentMonth } = useMonth();
  const { showSnackbar } = useSnackbar();
  const [data, setData] = React.useState([]);
  const [refreshing, setRefreshing] = React.useState(false);

  useFocusEffect(
    React.useCallback(() => {
      logger.navigationAction("MyScreen", { month: currentMonth });
      loadData();
    }, [currentMonth])
  );

  const loadData = async () => {
    const result = await loadMyData();
    setData(result);
  };

  // ... render
}
```

---

## Testing Checklist

Before completing any task:

- [ ] Linter passes with no errors
- [ ] All TypeScript types are properly defined
- [ ] User feedback is provided via Snackbar where appropriate
- [ ] Data persists correctly across app restarts
- [ ] Navigation works as expected (including month synchronization)
- [ ] UI is consistent with existing screens
- [ ] Code follows existing patterns
- [ ] Logger is used for navigation, user actions, and database operations
- [ ] Async database operations are properly handled with error cases
- [ ] Month context is used when screens display month-specific data

---

## Philosophy

**Planning-First Approach**

- Budget view is the primary workspace
- Users should see financial status at a glance
- Every interaction should feel intuitive
- Data flows seamlessly between views

**Code Quality**

- Write clean, readable code
- Follow existing patterns consistently
- Don't over-engineer solutions
- Prioritize user experience

---

## Quick Reference

**Show a notification:**

```typescript
showSnackbar("Message here");
```

**Navigate to another screen:**

```typescript
router.push("/(tabs)/categories");
```

**Format a date:**

```typescript
format(date, "MMMM yyyy"); // "January 2025"
format(date, "yyyy-MM-dd"); // "2025-01-15"
```

**Access theme colors:**

```typescript
theme.colors.primary;
theme.colors.error;
theme.colors.secondary;
```

**Use Month Context:**

```typescript
const { currentMonth, setCurrentMonth } = useMonth();
const monthKey = format(currentMonth, "yyyy-MM");
```

**Log operations:**

```typescript
logger.navigationAction("ScreenName", { month });
logger.userAction("action_name", { data });
logger.databaseSuccess("operation", { context });
logger.error(error, { operation: "operation_name" });
```

**Load data from database:**

```typescript
const data = await loadBudgets(monthKey);
const success = await saveBudget(budget);
```

---

**Remember: When in doubt, check the existing code for patterns, and always start with "YO ALPHA!" ðŸš€**
